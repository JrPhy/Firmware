看門狗實際上是一組計時器，主要是避免程式陷入無窮迴圈或無預期的錯誤造成系統死機，所以可以設定一個時間，當超過時間就跳回到某個狀態。又分成視窗看門狗 WWDG 與獨立看門狗 IWDG，[異同](https://mcu.eetrend.com/content/2020/100049481.html)可參考此篇。

## 1. 獨立看門狗 IWDG
顧名思義是利用獨立於其他計數器的部分來計時，獨立震盪器的頻率通常設為 40 kHz，通常會寫在主無窮迴圈中，也就是 main 中的無窮迴圈。
```C
int main(void) {
    //...
    IWDG_Config(IWDG_Prescaler_64 ,625);
    while(1)                            
    {	   
        if( Key_Scan(KEY1_GPIO_PORT,KEY1_PIN) == KEY_ON)
        {
            // ...
            IWDG_Feed();		
            // 餵狗後亮綠燈，若沒餵狗則會在時間到後再跳回上面
            LED_GREEN;
        }
    }
```
在 STM32 中，獨立看門狗的超時時間計算為```Tout = prv*rlv / 40 (ms)```，其中 prv 為第一個參數，IWDG_Prescaler_64 最後的 64 就是 prv 的值，rlv 為第二個參數，。所以以我們的例子，算出來的超時時間為 64*625/40 = 1000 ms = 1 s。通常來說超時設定會比預期要跑的時間多一點，也就是預期要跑 500 ms，則超時時間可以設 510 ms。

## 2. 窗口看門狗 WWDG
不同於獨立看門狗，窗口看門狗使用系統時鐘，精確度較於獨立看門狗高。一般用來監測外部干擾或不可預見的邏輯條件，造成的應用程式背離正常的運行序列而產生的軟體故障。窗口的意思是說當時間介於某個區間內餵狗表示正常，反之則不正常會回到迴圈一開始。下限通常設為 0x40，上限則根據實際情況設置，窗口介於 0x7F~0x40 間。
![image](https://github.com/user-attachments/assets/d70c6c65-824f-4576-99b2-1154d7f7a3d5)\
```C
int main(void)
{
    //...
    WWDG_Config(127,80,WWDG_Prescaler_8); // 初始化WWDG
    wwdg_wr = WWDG->CFR & 0X7F;
    //視窗值我們在初始化的時候設置成0x5F，這個值不會改變
    while(1)
    {
        LED2(OFF);
        wwdg_tr = WWDG->CR & 0X7F;
        if( wwdg_tr < wwdg_wr )
            WWDG_Feed(); // 餵狗，重新設置計數器的值為最大0X7F
	}
}
```
時間計算可[參考這篇](https://ithelp.ithome.com.tw/articles/10280416?sc=rss.iron)。
#### 中斷
與獨立看門狗不同，窗口看門狗可以有中斷，因為是使用系統時鐘，所以在進入中斷計時器仍繼續計時，所以要注意時間是否不再窗口內，否則就會直接復位。

一般工程都會使用兩個看門狗，獨立看門狗，主要用於在程式跑飛之後復位使用，一个是窗口看門狗，主要用于在復位前對於一些重要資料進行保存。
