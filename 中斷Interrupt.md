在寫多執行緒或是多進程程式時，會因為 CPU 核心數量與執行緒數量的關係，使得程式會依照優先順序執行。當然也會因為人為操作去調整每個部份的優先順序，例如[上下文交換(CONTEXT SWITCH)](https://github.com/JrPhy/Multiple_Thread/blob/main/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B%E8%88%87%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.md)時就是發生了中斷。在一般電腦架構下 CPU 與 OS 會做掉需要中斷的事情，所以開發者只須小心是否會有[競爭條件與死鎖發生](https://github.com/JrPhy/Multiple_Thread/blob/main/%E7%AB%B6%E7%88%AD%E6%A2%9D%E4%BB%B6%E8%88%87%E9%8E%96.md)。而在底層就叫需要知道到底發生了什麼事，一般軟體的中斷為軟體中斷，也就是會把當下的情況記錄在 PCB 中，等有空在去取 PCB 中的值繼續執行。除了軟體中斷外，還有外部中斷與內部中斷。

## 1. 為何需要中斷
在 IOT 設備的主機會一直去等待其他感測器的訊號，或是一直每隔一段時間發送訊號給感測器，所以內部就是一個無窮迴圈，此時 CPU 就是滿載的狀態，就無法去做其他事情。而且若是順序的去收發訊號，那麼當訊號丟失，或是不照著順序走就無法使用，使用起來非常沒有彈性，且收發訊號也只是瞬間的事，把大部分的時間都在做等待，無疑是浪費資源，如同在現實生活中，雖然只能一次做一件事，但是可以把在等某件事完成的時間拿去做另一件事，就可以大大的提升效率。所以就會利用中斷來收發訊號，也就是在要收訊號或發訊號時才將讓出資源，其餘時間就可以去做別的事。
![IMG](https://github.com/JrPhy/Firmware/blob/main/pic/ISR.jpg)

## 2. 內部中斷
由內部硬體所觸發的中斷，例如計時器中斷、串口中斷等。在接發訊號時比較常使用 [DMA 就是一種中斷](https://www.cnblogs.com/zhangshenghui/p/5340483.html)，只有當數據要進出 Register 時才需要去呼叫 CPU 要資源，可以用來檢測傳輸訊號是否完成或正確。

## 3. 外部中斷
在一些硬體上會有按鈕，當按下去後會讓電壓改變，可能是從高變低，也有可能是從低變高，主要就是抓到電位有變化就會觸發中斷訊號，又分為以下三種
1. 正沿觸發 (上升沿)
2. 負沿觸發 (下降沿)
3. 上升或下降觸發

STM32 內部有個邊沿電路檢測器，當電訊號從 GPIO 進入後就會先進到該檢測器
![IMG](https://i.loli.net/2019/07/18/5d305d1ee535277097.png)\
[來源](https://www.cnblogs.com/luoxiao23/p/11209630.html)

## 4. 中斷向量
在中斷發生時，我們需要記錄在前一刻所執行到的位置，以及要跳到哪個位置去執行其他事情，另外也會記錄優先級，會由高到低進行依序執行。如果兩個優先序相同，就看誰先排入隊列中。當然也有一種狀況是先從低優先序的函數近來，之後就一直有更高優先序的事件進來，也就是一直被插隊的情況，就稱為**巢狀中斷**。\
![IMG](https://letanphuc.net/content/images/size/w2000/2024/03/figure_2_nested_interrupt.jpg)\
[來源](https://letanphuc.net/2015/03/stm32f0-tutorial-3-external-interrupts/)

## 5. 中斷函數寫法
中斷函數必須是沒有引數與回傳值，且內部也盡量不要做其他事情，程式碼也盡量短，就只有跳到其他地址而已。
```C
void EXTI3_IRQHandler(void) {
    if(EXTI_GetITStatus != /*某訊號*/) {
        // 中斷邏輯
        EXTI_ClearITPendingBit(/*某條線*/)
    }
}
```
